<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>biobench.newt API documentation</title>
<meta name="description" content="NeWT: Natural World Tasks …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>biobench.newt</code></h1>
</header>
<section id="section-intro">
<h1 id="newt-natural-world-tasks">NeWT: Natural World Tasks</h1>
<p>NeWT is a collection of 164 binary classification tasks related to visual understanding of the natural world (<a href="https://arxiv.org/abs/2103.16483">CVPR 2021 paper</a>, <a href="https://github.com/visipedia/newt/tree/main">code</a>).</p>
<p>We evaluate a vision model by extracting visual features for each image, fitting a linear SVM to the training examples, and evaluating on the test data.
We aggregate scores across all 164 tasks.</p>
<p>If you use this evaluation, be sure to cite the original work:</p>
<pre><code>@inproceedings{van2021benchmarking,
  title={Benchmarking Representation Learning for Natural World Image Collections},
  author={Van Horn, Grant and Cole, Elijah and Beery, Sara and Wilber, Kimberly and Belongie, Serge and Mac Aodha, Oisin},
  booktitle={Computer Vision and Pattern Recognition},
  year={2021}
}
</code></pre>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="biobench.newt.download" href="download.html">biobench.newt.download</a></code></dt>
<dd>
<div class="desc"><p>A script to download the NeWT dataset …</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="biobench.newt.benchmark"><code class="name flex">
<span>def <span class="ident">benchmark</span></span>(<span>cfg: <a title="biobench.config.Experiment" href="../config.html#biobench.config.Experiment">Experiment</a>) ‑> <a title="biobench.reporting.Report" href="../reporting.html#biobench.reporting.Report">Report</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype.beartype
def benchmark(cfg: config.Experiment) -&gt; reporting.Report:
    &#34;&#34;&#34;
    The NeWT benchmark.
    First, get features for all images.
    Second, select the subsets of features that correspond to different tasks and train an SVM.
    Third, evaluate the SVM and report results.
    &#34;&#34;&#34;

    # Fit SVMs.
    all_preds = []
    for task in get_all_tasks(cfg):
        (x_train, y_train), (x_test, y_test) = task.splits

        x_mean = x_train.mean(axis=0, keepdims=True)

        x_train = x_train - x_mean
        x_train = l2_normalize(x_train)

        x_test = x_test - x_mean
        x_test = l2_normalize(x_test)

        svc = init_svc(cfg.n_train)

        svc.fit(x_train, y_train)
        y_pred = svc.predict(x_test)
        info = {
            &#34;task&#34;: task.name,
            &#34;cluster&#34;: task.cluster,
            &#34;subcluster&#34;: task.subcluster,
        }
        preds = [
            reporting.Prediction(str(id), float(pred == true), info)
            for id, pred, true in zip(task.example_ids, y_pred, y_test)
        ]

        all_preds.extend(preds)

    return reporting.Report(&#34;newt&#34;, all_preds, cfg)</code></pre>
</details>
<div class="desc"><p>The NeWT benchmark.
First, get features for all images.
Second, select the subsets of features that correspond to different tasks and train an SVM.
Third, evaluate the SVM and report results.</p></div>
</dd>
<dt id="biobench.newt.get_all_tasks"><code class="name flex">
<span>def <span class="ident">get_all_tasks</span></span>(<span>cfg: <a title="biobench.config.Experiment" href="../config.html#biobench.config.Experiment">Experiment</a>) ‑> Iterator[<a title="biobench.newt.Task" href="#biobench.newt.Task">Task</a>]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jaxtyped(typechecker=beartype.beartype)
@torch.no_grad()
def get_all_tasks(cfg: config.Experiment) -&gt; collections.abc.Iterator[Task]:
    &#34;&#34;&#34; &#34;&#34;&#34;
    rng = np.random.default_rng(seed=cfg.seed)

    # Load model
    backbone = registry.load_vision_backbone(cfg.model)
    img_transform = backbone.make_img_transform()
    backbone = torch.compile(backbone.to(cfg.device))

    labels_csv_name = &#34;newt2021_labels.csv&#34;
    labels_csv_path = os.path.join(cfg.data.newt, labels_csv_name)
    imgs_dir_name = &#34;newt2021_images&#34;
    imgs_dir_path = os.path.join(cfg.data.newt, imgs_dir_name)

    if not os.path.isfile(labels_csv_path):
        msg = f&#34;Path &#39;{labels_csv_path}&#39; doesn&#39;t exist. Did you download the Newt dataset? See the docstring at the top of this file for instructions. If you did download it, pass the path with &#39;--data&#39;; see --help for more.&#34;
        raise RuntimeError(msg)

    # Read the CSV and add row indices
    df = pl.read_csv(labels_csv_path).with_row_index(name=&#34;original_index&#34;)

    # Sample balanced training data for each task
    df = sample(rng, df, cfg.n_train).with_row_index(name=&#34;sampled_index&#34;)

    # Get all image IDs and labels
    all_data = df.select(&#34;id&#34;, &#34;label&#34;).to_numpy(structured=True)
    all_ids, all_labels = all_data[&#34;id&#34;], all_data[&#34;label&#34;]

    # Create dataset with all samples
    dataset = Dataset(
        imgs_dir_path,
        all_ids,
        all_labels,
        img_transform,
    )

    dataloader = torch.utils.data.DataLoader(
        dataset,
        batch_size=cfg.batch_size,
        num_workers=cfg.n_workers,
        drop_last=False,
        shuffle=False,
        pin_memory=False,
        persistent_workers=False,
    )

    all_features, all_ids = [], []

    # Need to select just a subset of rows based on cfg.n_train.
    total = len(dataloader) if not cfg.debug else 2
    it = iter(dataloader)
    for b in helpers.progress(range(total), every=10, desc=&#34;newt&#34;):
        batch = next(it)
        imgs = batch[&#34;img&#34;].to(cfg.device)

        with torch.amp.autocast(&#34;cuda&#34;):
            features = backbone.img_encode(imgs).img_features
            features = torch.nn.functional.normalize(features, dim=-1)
            all_features.append(features.cpu())

        all_ids.extend(batch[&#34;img_id&#34;])

    all_features = torch.cat(all_features, dim=0).cpu()
    all_ids = np.array(all_ids)

    for task in df.get_column(&#34;task&#34;).unique():
        task_df = df.filter(pl.col(&#34;task&#34;) == task)

        task_idx = task_df.get_column(&#34;sampled_index&#34;).to_numpy()
        features = all_features[task_idx].numpy()
        ids = all_ids[task_idx]

        labels = task_df.get_column(&#34;label&#34;).to_numpy()
        is_train = task_df.select(pl.col(&#34;split&#34;) == &#34;train&#34;).get_column(&#34;split&#34;)

        cluster = task_df.item(row=0, column=&#34;task_cluster&#34;)
        subcluster = task_df.item(row=0, column=&#34;task_subcluster&#34;)
        yield Task(
            task, cluster, subcluster, features, labels, is_train.to_numpy(), ids
        )</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="biobench.newt.init_svc"><code class="name flex">
<span>def <span class="ident">init_svc</span></span>(<span>n_train: int)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_svc(n_train: int):
    &#34;&#34;&#34;Create a new, randomly initialized SVM with a random hyperparameter search over kernel, C and gamma. It uses only 16 jobs in parallel to prevent overloading the CPUs on a shared machine.&#34;&#34;&#34;
    if n_train &lt; 10:
        return sklearn.pipeline.make_pipeline(
            sklearn.svm.SVC(kernel=&#34;linear&#34;),
        )

    return sklearn.model_selection.RandomizedSearchCV(
        sklearn.pipeline.make_pipeline(
            sklearn.preprocessing.StandardScaler(),
            sklearn.svm.SVC(C=1.0, kernel=&#34;rbf&#34;),
        ),
        {
            &#34;svc__C&#34;: scipy.stats.loguniform(a=1e-3, b=1e1),
            &#34;svc__kernel&#34;: [&#34;rbf&#34;, &#34;linear&#34;, &#34;sigmoid&#34;, &#34;poly&#34;],
            &#34;svc__gamma&#34;: scipy.stats.loguniform(a=1e-4, b=1e-3),
        },
        n_iter=100,
        n_jobs=16,
        random_state=42,
    )</code></pre>
</details>
<div class="desc"><p>Create a new, randomly initialized SVM with a random hyperparameter search over kernel, C and gamma. It uses only 16 jobs in parallel to prevent overloading the CPUs on a shared machine.</p></div>
</dd>
<dt id="biobench.newt.l2_normalize"><code class="name flex">
<span>def <span class="ident">l2_normalize</span></span>(<span>features: jaxtyping.Float[ndarray, 'batch dim']) ‑> jaxtyping.Float[ndarray, 'batch dim']</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jaxtyped(typechecker=beartype.beartype)
def l2_normalize(
    features: Float[np.ndarray, &#34;batch dim&#34;],
) -&gt; Float[np.ndarray, &#34;batch dim&#34;]:
    &#34;&#34;&#34;Normalizes a batch of vectors to have L2 unit norm.&#34;&#34;&#34;
    norms = np.linalg.norm(features, ord=2, axis=1, keepdims=True)
    return features / norms</code></pre>
</details>
<div class="desc"><p>Normalizes a batch of vectors to have L2 unit norm.</p></div>
</dd>
<dt id="biobench.newt.sample"><code class="name flex">
<span>def <span class="ident">sample</span></span>(<span>rng: numpy.random._generator.Generator,<br>df: polars.dataframe.frame.DataFrame,<br>n_train: int) ‑> polars.dataframe.frame.DataFrame</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jaxtyped(typechecker=beartype.beartype)
def sample(rng: np.random.Generator, df: pl.DataFrame, n_train: int) -&gt; pl.DataFrame:
    &#34;&#34;&#34;Sample a balanced subset of training data points for each task.

    Args:
        rng: Random number generator.
        df: NeWT dataframe.
        n_train: Number of training samples per task to return.

    Returns:
        A DataFrame with balanced training samples and all test samples.
    &#34;&#34;&#34;
    if n_train &lt;= 0:
        return df  # Return all data if n_train is not positive

    # Create a new dataframe to store the results
    result_dfs = []

    # Keep all test samples
    test_df = df.filter(pl.col(&#34;split&#34;) != &#34;train&#34;)
    result_dfs.append(test_df)

    # Process each task separately
    for task in df.get_column(&#34;task&#34;).unique():
        task_df = df.filter((pl.col(&#34;task&#34;) == task) &amp; (pl.col(&#34;split&#34;) == &#34;train&#34;))

        # Skip if the task has no training samples
        if task_df.height == 0:
            continue

        # Get samples for each class
        class0_df = task_df.filter(pl.col(&#34;label&#34;) == 0)
        class1_df = task_df.filter(pl.col(&#34;label&#34;) == 1)

        n0 = n_train // 2
        n1 = n_train - n0

        assert n0 &gt; 0
        assert n1 &gt; 0

        # Sample from each class
        if n0 &lt; class0_df.height:
            indices0 = rng.choice(class0_df.height, size=n0, replace=False)
            result_dfs.append(
                class0_df.with_row_index(name=&#34;tmp&#34;)
                .filter(pl.col(&#34;tmp&#34;).is_in(indices0))
                .drop(&#34;tmp&#34;)
            )
        else:
            result_dfs.append(class0_df)

        if n1 &lt; class1_df.height:
            indices1 = rng.choice(class1_df.height, size=n1, replace=False)
            result_dfs.append(
                class1_df.with_row_index(name=&#34;tmp&#34;)
                .filter(pl.col(&#34;tmp&#34;).is_in(indices1))
                .drop(&#34;tmp&#34;)
            )
        else:
            result_dfs.append(class1_df)

    # Combine all dataframes
    return pl.concat(result_dfs)</code></pre>
</details>
<div class="desc"><p>Sample a balanced subset of training data points for each task.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>rng</code></strong></dt>
<dd>Random number generator.</dd>
<dt><strong><code>df</code></strong></dt>
<dd>NeWT dataframe.</dd>
<dt><strong><code>n_train</code></strong></dt>
<dd>Number of training samples per task to return.</dd>
</dl>
<h2 id="returns">Returns</h2>
<p>A DataFrame with balanced training samples and all test samples.</p></div>
</dd>
<dt id="biobench.newt.score"><code class="name flex">
<span>def <span class="ident">score</span></span>(<span>preds: list[<a title="biobench.reporting.Prediction" href="../reporting.html#biobench.reporting.Prediction">Prediction</a>]) ‑> float</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype.beartype
def score(preds: list[reporting.Prediction]) -&gt; float:
    return np.mean([p.score for p in preds]).item()</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="biobench.newt.Dataset"><code class="flex name class">
<span>class <span class="ident">Dataset</span></span>
<span>(</span><span>root: str,<br>img_ids: jaxtyping.Shaped[ndarray, 'n'],<br>labels: jaxtyping.Int[ndarray, 'n'],<br>transform=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jaxtyped(typechecker=beartype.beartype)
class Dataset(torch.utils.data.Dataset):
    &#34;&#34;&#34;A dataset that returns ImageSample dictionaries.&#34;&#34;&#34;

    def __init__(
        self,
        root: str,
        img_ids: Shaped[np.ndarray, &#34; n&#34;],
        labels: Int[np.ndarray, &#34; n&#34;],
        transform=None,
    ):
        &#34;&#34;&#34;Initialize the dataset with image paths and labels.

        Args:
            root: Root directory containing the images.
            img_ids: Array of image IDs.
            labels: Array of binary labels corresponding to the images.
            transform: Optional transform to apply to the images.
        &#34;&#34;&#34;
        self.transform = transform
        self.root = root
        self.img_ids = img_ids
        self.labels = labels

    def __getitem__(self, i: int) -&gt; Sample:
        &#34;&#34;&#34;Get a sample by its index.

        Args:
            i: Index of the sample to retrieve.

        Returns:
            A dictionary containing the image ID, image tensor, and label.
        &#34;&#34;&#34;
        img_id = self.img_ids[i]
        img = Image.open(os.path.join(self.root, f&#34;{img_id}.jpg&#34;))
        if self.transform is not None:
            img = self.transform(img)
        label = self.labels[i]
        return {&#34;img_id&#34;: img_id, &#34;img&#34;: img, &#34;label&#34;: label}

    def __len__(self) -&gt; int:
        &#34;&#34;&#34;Return the number of samples in the dataset.

        Returns:
            The number of samples.
        &#34;&#34;&#34;
        return len(self.img_ids)</code></pre>
</details>
<div class="desc"><p>A dataset that returns ImageSample dictionaries.</p>
<p>Initialize the dataset with image paths and labels.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>root</code></strong></dt>
<dd>Root directory containing the images.</dd>
<dt><strong><code>img_ids</code></strong></dt>
<dd>Array of image IDs.</dd>
<dt><strong><code>labels</code></strong></dt>
<dd>Array of binary labels corresponding to the images.</dd>
<dt><strong><code>transform</code></strong></dt>
<dd>Optional transform to apply to the images.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>torch.utils.data.dataset.Dataset</li>
<li>typing.Generic</li>
</ul>
</dd>
<dt id="biobench.newt.Sample"><code class="flex name class">
<span>class <span class="ident">Sample</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jaxtyped(typechecker=beartype.beartype)
class Sample(typing.TypedDict):
    &#34;&#34;&#34;A dictionary representing a single image sample with its metadata.

    Attributes:
        img_id: Unique identifier for the image.
        img: The image tensor with shape [3, width, height] (RGB channels first).
        label: Binary class label (0 or 1) for the image.
    &#34;&#34;&#34;

    img_id: str
    img: Float[Tensor, &#34;3 width height&#34;]
    label: Int[Tensor, &#34;&#34;]</code></pre>
</details>
<div class="desc"><p>A dictionary representing a single image sample with its metadata.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>img_id</code></strong></dt>
<dd>Unique identifier for the image.</dd>
<dt><strong><code>img</code></strong></dt>
<dd>The image tensor with shape [3, width, height] (RGB channels first).</dd>
<dt><strong><code>label</code></strong></dt>
<dd>Binary class label (0 or 1) for the image.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="biobench.newt.Sample.img"><code class="name">var <span class="ident">img</span> : jaxtyping.Float[Tensor, '3 width height']</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="biobench.newt.Sample.img_id"><code class="name">var <span class="ident">img_id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="biobench.newt.Sample.label"><code class="name">var <span class="ident">label</span> : jaxtyping.Int[Tensor, '']</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="biobench.newt.Task"><code class="flex name class">
<span>class <span class="ident">Task</span></span>
<span>(</span><span>name: str,<br>cluster: str,<br>subcluster: str | None,<br>features: jaxtyping.Float[ndarray, 'batch dim'],<br>labels: jaxtyping.Int[ndarray, 'batch'],<br>is_train: jaxtyping.Bool[ndarray, 'batch'],<br>example_ids: jaxtyping.Shaped[ndarray, 'batch'])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jaxtyped(typechecker=beartype.beartype)
@dataclasses.dataclass(frozen=True)
class Task:
    &#34;&#34;&#34;
    Task is a group of features and labels for an SVM + a train/test split.
    &#34;&#34;&#34;

    name: str
    cluster: str
    subcluster: str | None
    features: Float[np.ndarray, &#34;batch dim&#34;]
    labels: Int[np.ndarray, &#34; batch&#34;]
    is_train: Bool[np.ndarray, &#34; batch&#34;]
    example_ids: Shaped[np.ndarray, &#34; batch&#34;]  # Should be String[...]

    def __repr__(self) -&gt; str:
        return f&#34;Task(task={self.name}, cluster={self.cluster}, features={self.features.shape})&#34;

    @property
    def splits(
        self,
    ) -&gt; tuple[
        tuple[Float[np.ndarray, &#34;n_train dim&#34;], Int[np.ndarray, &#34; n_train&#34;]],
        tuple[Float[np.ndarray, &#34;n_test dim&#34;], Int[np.ndarray, &#34; n_test&#34;]],
    ]:
        &#34;&#34;&#34;
        The features and labels for train and test splits.

        Returned as `(x_train, y_train), (x_test, y_test)`.
        &#34;&#34;&#34;
        x_train = self.features[self.is_train]
        y_train = self.labels[self.is_train]
        x_test = self.features[~self.is_train]
        y_test = self.labels[~self.is_train]

        return (x_train, y_train), (x_test, y_test)</code></pre>
</details>
<div class="desc"><p>Task is a group of features and labels for an SVM + a train/test split.</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="biobench.newt.Task.cluster"><code class="name">var <span class="ident">cluster</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="biobench.newt.Task.example_ids"><code class="name">var <span class="ident">example_ids</span> : jaxtyping.Shaped[ndarray, 'batch']</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="biobench.newt.Task.features"><code class="name">var <span class="ident">features</span> : jaxtyping.Float[ndarray, 'batch dim']</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="biobench.newt.Task.is_train"><code class="name">var <span class="ident">is_train</span> : jaxtyping.Bool[ndarray, 'batch']</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="biobench.newt.Task.labels"><code class="name">var <span class="ident">labels</span> : jaxtyping.Int[ndarray, 'batch']</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="biobench.newt.Task.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="biobench.newt.Task.splits"><code class="name">prop <span class="ident">splits</span> : tuple[tuple[jaxtyping.Float[ndarray, 'n_train dim'], jaxtyping.Int[ndarray, 'n_train']], tuple[jaxtyping.Float[ndarray, 'n_test dim'], jaxtyping.Int[ndarray, 'n_test']]]</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def splits(
    self,
) -&gt; tuple[
    tuple[Float[np.ndarray, &#34;n_train dim&#34;], Int[np.ndarray, &#34; n_train&#34;]],
    tuple[Float[np.ndarray, &#34;n_test dim&#34;], Int[np.ndarray, &#34; n_test&#34;]],
]:
    &#34;&#34;&#34;
    The features and labels for train and test splits.

    Returned as `(x_train, y_train), (x_test, y_test)`.
    &#34;&#34;&#34;
    x_train = self.features[self.is_train]
    y_train = self.labels[self.is_train]
    x_test = self.features[~self.is_train]
    y_test = self.labels[~self.is_train]

    return (x_train, y_train), (x_test, y_test)</code></pre>
</details>
<div class="desc"><p>The features and labels for train and test splits.</p>
<p>Returned as <code>(x_train, y_train), (x_test, y_test)</code>.</p></div>
</dd>
<dt id="biobench.newt.Task.subcluster"><code class="name">var <span class="ident">subcluster</span> : str | None</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul>
<li><a href="#newt-natural-world-tasks">NeWT: Natural World Tasks</a></li>
</ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="biobench" href="../index.html">biobench</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="biobench.newt.download" href="download.html">biobench.newt.download</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="biobench.newt.benchmark" href="#biobench.newt.benchmark">benchmark</a></code></li>
<li><code><a title="biobench.newt.get_all_tasks" href="#biobench.newt.get_all_tasks">get_all_tasks</a></code></li>
<li><code><a title="biobench.newt.init_svc" href="#biobench.newt.init_svc">init_svc</a></code></li>
<li><code><a title="biobench.newt.l2_normalize" href="#biobench.newt.l2_normalize">l2_normalize</a></code></li>
<li><code><a title="biobench.newt.sample" href="#biobench.newt.sample">sample</a></code></li>
<li><code><a title="biobench.newt.score" href="#biobench.newt.score">score</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="biobench.newt.Dataset" href="#biobench.newt.Dataset">Dataset</a></code></h4>
</li>
<li>
<h4><code><a title="biobench.newt.Sample" href="#biobench.newt.Sample">Sample</a></code></h4>
<ul class="">
<li><code><a title="biobench.newt.Sample.img" href="#biobench.newt.Sample.img">img</a></code></li>
<li><code><a title="biobench.newt.Sample.img_id" href="#biobench.newt.Sample.img_id">img_id</a></code></li>
<li><code><a title="biobench.newt.Sample.label" href="#biobench.newt.Sample.label">label</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="biobench.newt.Task" href="#biobench.newt.Task">Task</a></code></h4>
<ul class="two-column">
<li><code><a title="biobench.newt.Task.cluster" href="#biobench.newt.Task.cluster">cluster</a></code></li>
<li><code><a title="biobench.newt.Task.example_ids" href="#biobench.newt.Task.example_ids">example_ids</a></code></li>
<li><code><a title="biobench.newt.Task.features" href="#biobench.newt.Task.features">features</a></code></li>
<li><code><a title="biobench.newt.Task.is_train" href="#biobench.newt.Task.is_train">is_train</a></code></li>
<li><code><a title="biobench.newt.Task.labels" href="#biobench.newt.Task.labels">labels</a></code></li>
<li><code><a title="biobench.newt.Task.name" href="#biobench.newt.Task.name">name</a></code></li>
<li><code><a title="biobench.newt.Task.splits" href="#biobench.newt.Task.splits">splits</a></code></li>
<li><code><a title="biobench.newt.Task.subcluster" href="#biobench.newt.Task.subcluster">subcluster</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>

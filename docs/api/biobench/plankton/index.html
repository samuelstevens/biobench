<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>biobench.plankton API documentation</title>
<meta name="description" content="Classification of phytoplankton using ridge classifiers.
This task is particularly challenging because the image distribution is very different to …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>biobench.plankton</code></h1>
</header>
<section id="section-intro">
<p>Classification of phytoplankton using ridge classifiers.
This task is particularly challenging because the image distribution is very different to typical pre-training datasets; it's all microscopic images in mono-channel (black and white).</p>
<p>If you use this task, please cite the original paper to propose this train/test split and the original datasets as well:</p>
<p>Paper:</p>
<pre><code>@article{kaisa2022towards,
    author={Kraft, Kaisa  and Velhonoja, Otso  and Eerola, Tuomas  and Suikkanen, Sanna  and Tamminen, Timo  and Haraguchi, Lumi  and Ylöstalo, Pasi  and Kielosto, Sami  and Johansson, Milla  and Lensu, Lasse  and Kälviäinen, Heikki  and Haario, Heikki  and Seppälä, Jukka },
    title={Towards operational phytoplankton recognition with automated high-throughput imaging, near-real-time data processing, and convolutional neural networks},
    journal={Frontiers in Marine Science},
    volume={9},
    year={2022},
    url={https://www.frontiersin.org/journals/marine-science/articles/10.3389/fmars.2022.867695},
    doi={10.3389/fmars.2022.867695},
    issn={2296-7745},
}
</code></pre>
<p>Training data:</p>
<pre><code>@misc{kaisa2022syke
    doi = {10.23728/B2SHARE.ABF913E5A6AD47E6BAA273AE0ED6617A},
    url = {https://b2share.eudat.eu/records/abf913e5a6ad47e6baa273ae0ed6617a},
    author = {Kraft, Kaisa and Velhonoja, Otso and Seppälä, Jukka and Hällfors, Heidi and Suikkanen, Sanna and Ylöstalo, Pasi and Anglès, Sílvia and Kielosto, Sami and Kuosa, Harri and Lehtinen, Sirpa and Oja, Johanna and Tamminen, Timo},
    keywords = {3.1.21 -&gt; Biology -&gt; Marine biology, phytoplankton image data set, imaging flow cytometry, Imaging FlowCytobot, IFCB, phytoplankton, Baltic Sea, image data, SYKE, Finnish Environment Institute, Marine Research Centre, Marine Ecological Research Laboratory, plankton image data, FINMARI},
    title = {SYKE-plankton_IFCB_2022},
    publisher = {https://b2share.eudat.eu},
    year = {2022},
    copyright = {open}
}
</code></pre>
<p>Evaluation data:</p>
<pre><code>@misc{kaisa2021syke,
  doi = {10.23728/B2SHARE.7C273B6F409C47E98A868D6517BE3AE3},
  url = {https://b2share.eudat.eu/records/7c273b6f409c47e98a868d6517be3ae3},
  author = {Kraft, Kaisa and Haraguchi, Lumi and Velhonoja, Otso and Seppälä, Jukka},
  keywords = {3.1.21 -&gt; Biology -&gt; Marine biology, phytoplankton image data set, imaging flow cytometry, Imaging FlowCytobot, IFCB, Baltic Sea, image data, SYKE, Finnish Environment Institute, Marine Research Centre, Marine Ecological Research Laboratory, plankton image data, FINMARI, phytoplankton},
  title = {SYKE-plankton_IFCB_Utö_2021},
  publisher = {https://b2share.eudat.eu},
  year = {2022},
  copyright = {open}
}
</code></pre>
<p>This task was added because of interesting conversations with <a href="https://scholar.google.com/citations?user=lmYki4gAAAAJ">Ekaterina Nepovinnykh</a> and <a href="https://www.lut.fi/en/profiles/heikki-kalviainen">Heikki Kälviäinen</a>.</p>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="biobench.plankton.download" href="download.html">biobench.plankton.download</a></code></dt>
<dd>
<div class="desc"><p>A script to download the SYKE-plankton_IFCB_2022 dataset …</p></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="biobench.plankton.benchmark"><code class="name flex">
<span>def <span class="ident">benchmark</span></span>(<span>cfg: <a title="biobench.config.Experiment" href="../config.html#biobench.config.Experiment">Experiment</a>) ‑> <a title="biobench.reporting.Report" href="../reporting.html#biobench.reporting.Report">Report</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@beartype.beartype
def benchmark(cfg: config.Experiment) -&gt; reporting.Report:
    &#34;&#34;&#34;
    Steps:
    1. Get features for all images.
    2. Select lambda using cross validation splits.
    3. Report score on test data.
    &#34;&#34;&#34;
    backbone = registry.load_vision_backbone(cfg.model)

    # 1. Get features
    train_features = get_features(cfg, backbone, is_train=True)
    val_features = get_features(cfg, backbone, is_train=False)

    torch.cuda.empty_cache()  # Be nice to others on the machine.

    # 2. Fit model.
    clf = helpers.init_logreg_clf(cfg)
    clf.fit(train_features.x, train_features.y)

    # 3. Predict.
    pred_labels = clf.predict(val_features.x)
    logger.info(&#34;Predicted classes for %d examples.&#34;, len(val_features.x))
    true_labels = val_features.y

    preds = [
        reporting.Prediction(
            str(image_id),
            float(pred == true),
            {&#34;y_pred&#34;: pred.item(), &#34;y_true&#34;: true.item()},
        )
        for image_id, pred, true in zip(val_features.ids, pred_labels, true_labels)
    ]

    return reporting.Report(&#34;plankton&#34;, preds, cfg)</code></pre>
</details>
<div class="desc"><p>Steps:
1. Get features for all images.
2. Select lambda using cross validation splits.
3. Report score on test data.</p></div>
</dd>
<dt id="biobench.plankton.bootstrap_scores"><code class="name flex">
<span>def <span class="ident">bootstrap_scores</span></span>(<span>df: polars.dataframe.frame.DataFrame,<br>*,<br>b: int = 0,<br>rng: numpy.random._generator.Generator | None = None) ‑> dict[str, jaxtyping.Float[ndarray, 'b']]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jaxtyped(typechecker=beartype.beartype)
def bootstrap_scores(
    df: pl.DataFrame, *, b: int = 0, rng: np.random.Generator | None = None
) -&gt; dict[str, Float[np.ndarray, &#34; b&#34;]]:
    assert df.get_column(&#34;task_name&#34;).unique().to_list() == [&#34;plankton&#34;]
    return reporting.bootstrap_scores_macro_f1(df, b=b, rng=rng)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="biobench.plankton.get_features"><code class="name flex">
<span>def <span class="ident">get_features</span></span>(<span>cfg: <a title="biobench.config.Experiment" href="../config.html#biobench.config.Experiment">Experiment</a>,<br>backbone: <a title="biobench.registry.VisionBackbone" href="../registry.html#biobench.registry.VisionBackbone">VisionBackbone</a>,<br>*,<br>is_train: bool) ‑> <a title="biobench.plankton.Features" href="#biobench.plankton.Features">Features</a></span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jaxtyped(typechecker=beartype.beartype)
@torch.no_grad()
def get_features(
    cfg: config.Experiment, backbone: registry.VisionBackbone, *, is_train: bool
) -&gt; Features:
    split = &#34;train&#34; if is_train else &#34;val&#34;
    images_dir_path = os.path.join(cfg.data.plankton, split)

    img_transform = backbone.make_img_transform()
    backbone = torch.compile(backbone.to(cfg.device))

    dataset = Dataset(images_dir_path, img_transform)

    if is_train and cfg.n_train &gt; 0:
        i = helpers.balanced_random_sample(dataset.labels, cfg.n_train)
        assert len(i) == cfg.n_train
        dataset = torch.utils.data.Subset(dataset, i)

    dataloader = torch.utils.data.DataLoader(
        dataset,
        batch_size=cfg.batch_size,
        num_workers=cfg.n_workers,
        drop_last=False,
        shuffle=False,
        pin_memory=False,
        persistent_workers=False,
    )

    def probe(batch):
        imgs = batch[&#34;img&#34;].to(cfg.device, non_blocking=True)
        with torch.amp.autocast(cfg.device):
            _ = backbone.img_encode(imgs).img_features  # forward only

    all_ids, all_features, all_labels = [], [], []

    with helpers.auto_batch_size(dataloader, probe=probe):
        total = len(dataloader) if not cfg.debug else 2
        it = iter(dataloader)
        for b in helpers.progress(range(total), every=10, desc=f&#34;plk/{split}&#34;):
            batch = next(it)
            imgs = batch[&#34;img&#34;].to(cfg.device)

            with torch.amp.autocast(cfg.device):
                features = backbone.img_encode(imgs).img_features
                all_features.append(features.cpu())

            all_ids.extend(batch[&#34;img_id&#34;])

            all_labels.extend(batch[&#34;label&#34;])

    all_features = torch.cat(all_features, axis=0).cpu().numpy()
    all_labels = np.array(all_labels)
    all_ids = np.array(all_ids)
    assert len(all_ids) == len(dataset)
    logger.info(&#34;Got features for %d images.&#34;, len(all_ids))

    return Features(all_features, all_labels, all_ids)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="biobench.plankton.Dataset"><code class="flex name class">
<span>class <span class="ident">Dataset</span></span>
<span>(</span><span>root: str, transform)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jaxtyped(typechecker=beartype.beartype)
class Dataset(torch.utils.data.Dataset):
    transform: typing.Any | None
    &#34;&#34;&#34;Optional function function that transforms an image into a format expected by a neural network.&#34;&#34;&#34;
    samples: list[tuple[str, str, str]]
    &#34;&#34;&#34;List of all image ids, image paths, and classnames.&#34;&#34;&#34;

    def __init__(self, root: str, transform):
        self.transform = transform
        self.samples = []
        if not os.path.exists(root) or not os.path.isdir(root):
            msg = f&#34;Path &#39;{root}&#39; doesn&#39;t exist. Did you download the plankton dataset? See the docstring at the top of this file for instructions.&#34;
            raise RuntimeError(msg)

        class_to_int = {}
        for dirname in sorted(os.listdir(root)):
            class_to_int[dirname] = len(class_to_int)

        for dirpath, dirnames, filenames in os.walk(root):
            img_class = os.path.relpath(dirpath, root)
            for filename in filenames:
                if not filename.endswith(&#34;.png&#34;):
                    continue
                img_id = filename.removesuffix(&#34;.png&#34;)
                img_path = os.path.join(dirpath, filename)
                self.samples.append((img_id, img_path, class_to_int[img_class]))

    def __getitem__(self, i) -&gt; Sample:
        img_id, img_path, label = self.samples[i]
        img = Image.open(img_path).convert(&#34;RGB&#34;)
        if self.transform is not None:
            img = self.transform(img)
        return {&#34;img_id&#34;: img_id, &#34;img&#34;: img, &#34;label&#34;: label}

    def __len__(self) -&gt; int:
        return len(self.samples)

    @property
    def labels(self) -&gt; Int[np.ndarray, &#34; n_samples&#34;]:
        return np.array([label for _, _, label in self.samples])</code></pre>
</details>
<div class="desc"><p>An abstract class representing a :class:<code><a title="biobench.plankton.Dataset" href="#biobench.plankton.Dataset">Dataset</a></code>.</p>
<p>All datasets that represent a map from keys to data samples should subclass
it. All subclasses should overwrite :meth:<code>__getitem__</code>, supporting fetching a
data sample for a given key. Subclasses could also optionally overwrite
:meth:<code>__len__</code>, which is expected to return the size of the dataset by many
:class:<code>~torch.utils.data.Sampler</code> implementations and the default options
of :class:<code>~torch.utils.data.DataLoader</code>. Subclasses could also
optionally implement :meth:<code>__getitems__</code>, for speedup batched samples
loading. This method accepts list of indices of samples of batch and returns
list of samples.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>:class:<code>~torch.utils.data.DataLoader</code> by default constructs an index
sampler that yields integral indices.
To make it work with a map-style
dataset with non-integral indices/keys, a custom sampler must be provided.</p>
</div></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>torch.utils.data.dataset.Dataset</li>
<li>typing.Generic</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="biobench.plankton.Dataset.samples"><code class="name">var <span class="ident">samples</span> : list[tuple[str, str, str]]</code></dt>
<dd>
<div class="desc"><p>List of all image ids, image paths, and classnames.</p></div>
</dd>
<dt id="biobench.plankton.Dataset.transform"><code class="name">var <span class="ident">transform</span> : typing.Any | None</code></dt>
<dd>
<div class="desc"><p>Optional function function that transforms an image into a format expected by a neural network.</p></div>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="biobench.plankton.Dataset.labels"><code class="name">prop <span class="ident">labels</span> : jaxtyping.Int[ndarray, 'n_samples']</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def labels(self) -&gt; Int[np.ndarray, &#34; n_samples&#34;]:
    return np.array([label for _, _, label in self.samples])</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="biobench.plankton.Features"><code class="flex name class">
<span>class <span class="ident">Features</span></span>
<span>(</span><span>x: jaxtyping.Float[ndarray, 'n dim'],<br>y: jaxtyping.Int[ndarray, 'n'],<br>ids: jaxtyping.Shaped[ndarray, 'n'])</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jaxtyped(typechecker=beartype.beartype)
@dataclasses.dataclass(frozen=True)
class Features:
    x: Float[np.ndarray, &#34;n dim&#34;]
    y: Int[np.ndarray, &#34; n&#34;]
    ids: Shaped[np.ndarray, &#34; n&#34;]</code></pre>
</details>
<div class="desc"><p>Features(x: jaxtyping.Float[ndarray, 'n dim'], y: jaxtyping.Int[ndarray, 'n'], ids: jaxtyping.Shaped[ndarray, 'n'])</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="biobench.plankton.Features.ids"><code class="name">var <span class="ident">ids</span> : jaxtyping.Shaped[ndarray, 'n']</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="biobench.plankton.Features.x"><code class="name">var <span class="ident">x</span> : jaxtyping.Float[ndarray, 'n dim']</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="biobench.plankton.Features.y"><code class="name">var <span class="ident">y</span> : jaxtyping.Int[ndarray, 'n']</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="biobench.plankton.Sample"><code class="flex name class">
<span>class <span class="ident">Sample</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@jaxtyped(typechecker=beartype.beartype)
class Sample(typing.TypedDict):
    &#34;&#34;&#34;A dictionary representing a single image sample with its metadata.

    Attributes:
        img_id: Unique identifier for the image.
        img: The image tensor with shape [3, width, height] (RGB channels first).
        label: Binary class label (0 or 1) for the image.
    &#34;&#34;&#34;

    img_id: str
    img: Float[Tensor, &#34;3 width height&#34;]
    label: Int[Tensor, &#34;&#34;]</code></pre>
</details>
<div class="desc"><p>A dictionary representing a single image sample with its metadata.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>img_id</code></strong></dt>
<dd>Unique identifier for the image.</dd>
<dt><strong><code>img</code></strong></dt>
<dd>The image tensor with shape [3, width, height] (RGB channels first).</dd>
<dt><strong><code>label</code></strong></dt>
<dd>Binary class label (0 or 1) for the image.</dd>
</dl></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.dict</li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="biobench.plankton.Sample.img"><code class="name">var <span class="ident">img</span> : jaxtyping.Float[Tensor, '3 width height']</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="biobench.plankton.Sample.img_id"><code class="name">var <span class="ident">img_id</span> : str</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="biobench.plankton.Sample.label"><code class="name">var <span class="ident">label</span> : jaxtyping.Int[Tensor, '']</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="biobench" href="../index.html">biobench</a></code></li>
</ul>
</li>
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="biobench.plankton.download" href="download.html">biobench.plankton.download</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="biobench.plankton.benchmark" href="#biobench.plankton.benchmark">benchmark</a></code></li>
<li><code><a title="biobench.plankton.bootstrap_scores" href="#biobench.plankton.bootstrap_scores">bootstrap_scores</a></code></li>
<li><code><a title="biobench.plankton.get_features" href="#biobench.plankton.get_features">get_features</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="biobench.plankton.Dataset" href="#biobench.plankton.Dataset">Dataset</a></code></h4>
<ul class="">
<li><code><a title="biobench.plankton.Dataset.labels" href="#biobench.plankton.Dataset.labels">labels</a></code></li>
<li><code><a title="biobench.plankton.Dataset.samples" href="#biobench.plankton.Dataset.samples">samples</a></code></li>
<li><code><a title="biobench.plankton.Dataset.transform" href="#biobench.plankton.Dataset.transform">transform</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="biobench.plankton.Features" href="#biobench.plankton.Features">Features</a></code></h4>
<ul class="">
<li><code><a title="biobench.plankton.Features.ids" href="#biobench.plankton.Features.ids">ids</a></code></li>
<li><code><a title="biobench.plankton.Features.x" href="#biobench.plankton.Features.x">x</a></code></li>
<li><code><a title="biobench.plankton.Features.y" href="#biobench.plankton.Features.y">y</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="biobench.plankton.Sample" href="#biobench.plankton.Sample">Sample</a></code></h4>
<ul class="">
<li><code><a title="biobench.plankton.Sample.img" href="#biobench.plankton.Sample.img">img</a></code></li>
<li><code><a title="biobench.plankton.Sample.img_id" href="#biobench.plankton.Sample.img_id">img_id</a></code></li>
<li><code><a title="biobench.plankton.Sample.label" href="#biobench.plankton.Sample.label">label</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
